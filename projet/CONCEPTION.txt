semaine 1: Quand nous avons commencé à programmer nous voulions faire un peu différamment certaines choses
qui étaient prévues sur le site du projet mais au final, après réflexion nous nous sommes restreints à faire
précisémment ce qui était demandé car cela nous semble être la meilleure manière de procéder (pour cette partie du projet).

La définition de la classe Vecteur qui contient les prototypes des méthodes ainsi que l'attribut composantes se situe dans le .h
Le.cc contient le main ainsi que les définitions de toutes les méthodes.

Temps de travail estimé: 5h

semaine 2: Nous avons ajouter le Makefile ainsi qu'installer une VM sur l'un des ordinateurs. Nous avions déjà séparé en 
3 parties la Classe Vecteur. Nous avons aussi rajouté une struct d'erreurs afin de faciliter la gestion des exceptions

semaine 3: ajout d'opérateur pour l'addition (+= et +), la soustraction (-= et -), la multiplication par un scalaire (*= et *), le produit vectoriel (^), le produit scalaire(*), vecteur unitaire(~),
affichage (cout<< vec) et test de comparaison (== et !=).

semaine 4: Ajout de deux fichier Balle.cpp et Balle.h ainsi que ChampForces.cpp et ChampForces.h, nous avons décidé de modifier la masse si la masse volumique changeait
et inversement, çela nous rajoute 4 méthodes mais rend les deux modifications plus "logique"  d'un point de vue physique. nous avons aussi décidé de crée les 4 constructeurs 
proposés.

semaine 5: Comme cette semaine a été une grosse semaine en terme de quantité de code je vais expliquer l'arboresence des classes dans l'état actuel.
    Au sommet, il y a la classe Objet qui se sépare ensuite en 2 branches.
    Branche 1: ObjetMobile qui lui même se sépare en 3 branches: Pendule/Balle/Ressort
    Branche 2: Obstacles qui lui même se sépare entre 2 branches: Plan/Brique
    De plus Plan contient encore une sous classe : Portion_plan

    A côté de cette "famille" de classe Objets nous avons encore les classes Integrateurs.
    Integrateur se décompose en Integrateur_E (Euler) et en Integrateur_EC (Euler/Cromer)

    Les classes Objets, Obstacles, ObjetMobile et Integrateur sont des classes abstraites; on ne peut donc pas déclarer une instance d'une de ces classes

    La classe ObjetMobile reprend dans l'essentiel l'ancienne classe Balle. On a donc "transférer" la classe Balle dans ObjetMobile.
    La classe Balle ne contient donc plus d'attributs mais possède encore ses getteurs et setteurs ainsi que sa fonction d'évolution.
    La classe Pendule ajoute à ObjetMobile les attributs longueur, frottement, direction, position_masse, vitesse_masse. A noter que param et dev_temp param représentent un angle et une vitesse angulaire.
    La classe Ressort ajoute à ObjetMobile les attributs longueur_repos, k, frottement, direction, position_masse, vitesse_masse. A noter que param et dev_temp param représente la position et la vitesse le long du vecteur direction.

    Ces 3 dernières classes ont chacune leur propre fonction d'evolution qui est utilisée par les différents intégrateurs

    Une méthode distance fait aussi partie de la classe ObjetMobile; elle permet de mesurer la distance entre deux objets mobiles.
    Pour se faire les masses respectivement acrochées au bout du pendule et d'un ressort sont considérées comme des sphères.
    Cette méthode retourne donc la distance bord à bord en non pas centre à centre. 

    La classe Obstacles ne contient aucun attribut car son attribut principal: position_origine se trouve dans Objets
    La classe Plan est caractérisée par une normale
    La classe Portion_plan est caractérisée par une normale (dans Plan) ainsi que deux scalaires longueur et largeur et encore deux vecteurs unitaires Elarg et Elong
    Lors de la création d'une portion de plan, si les deux vecteurs donnés ne sont pas perpendiculaires un correctif est ajouté afin d'en avoir 2 perpendiculaires.
    C'est la raison pour laquelle nous avons décidé de passer aussi en paramètres dans le constructeur les 2 scalaires; comme ça en cas de modifications d'un des 2 vecteurs les normes sont conservées
    La classe Brique est caractérisée par 3 scalaires longueur_, largeur_ et hauteur  ainsi que de 3 vecteurs unitaires normal,longueur et largeur.
    La même réflexion a été faite concernant 2 vecteurs non perpendiculaires que dans les portions de plan.

    Toutes les classes de types Obstacles possède une méthode distance et calcul_point_proche qui prennent les 2 en paramètre un objet mobile.

    La classe Integrateur possède comme attribut dt. Cet attribut représente le pas de temps caractéristique d'un intégrateur et est quelque chose en commun à tous les intégrateurs.
    La méthode intègre que les deux sous classes d'Integrateur possède font appel à la fonction evolution d'un objet mobile en particulier.
    Grâce au polymorphisme une seule méthode intègre suffit par type d'intégrateurs (donc par classe)

semaine 6: Les classes Systeme, Dessinable, SupportDessin, Textviewer ont été ajoutées au projet.
    Systeme: déjà décrite dans la réponse P8.4 (REPONSES.txt). De plus, cette classe est une sous-classe de Dessinable mais est indépendante de la branche "Objets"
    Dessinable: Interface abstraite qui possède seulement la méthode virtuelle pur dessine_sur. De plus elle est la super classe de Objets, car on veut pouvoir dessiner les différents objets.
    SupportDessin: Interface abstraite qui contient les méthodes virtuelles pures des différents objets dessinables.
    Textviewer: Sous-classe de SupportDessin dédié à la représentation du système sous forme textuelle. Toutes les méthodes virtuelles pures de SupportDessin sont explicitement définies.
    Ces dernières consistent simplement à cout<<Type_Objets_Dessinables. Cependant l'affichage peut être modifié par rapport au cout<<Type_Objets_Dessinables standard grâce à l'ajout d'un paramètre
    de type bool complet dans toutes les méthodes affiches des objets mobiles. En choisissant false, seul un nombre restreint de données sur l'objet mobile sera affiché.

    De plus, la gestion des chocs grâce aux méthodes agit_sur ont été ajoutées telles qu'elles sont présentées dans le complément mathématique. Cependant, nous avons décidé d'ajouter un méthode
    actualise_vitesse_choc() qui s'adapte au type d'objets mobiles en question afin que par exemple le pendule n'obtienne pas un vitesse le long de sa barre. De plus nous avons encore ajouté à la classe 
    ObjetMobile une méthode virtuelle pure get_force_choc() --> cette dernière possède une utilité pour la classe Pendule lors des chocs. En effet la force du pendule que nous devons prendre lors d'un choc
    n'est pas l'attribut standard de la classe ObjetMobile mais bien la force qui agit sur la masse au bout du pendule. Cette méthode est déclarée au niveau d'ObjetMobile car on veut pouvoir l'utiliser de manière
    polymorphique pour un ObjetMobile dans agit_sur() d'ObjetMobile. Le même raisonnement est effectué pour un ressort.

    
