P1.1 : Les vecteurs sont représentés par des vector<double>. Cela permet de rester flexible
sur les changements de dimensions et représente une manière intuitive de représenter un vecteur.

Le vector<double> qui représente donc les composantes du vecteur constitue l'unique attribut (privé) du vecteur.
Cela a été en privé dans le but que seulement les méthodes de la classe puissent modifier le vecteur. Et "cacher"
les attributs au programmeur utilisateur nous permet de mieux proteger la structure de notre Classe Vecteur et de 
lui fournir que les outils essentiels au bon fonctionnement du programme.

Toutes les méthodes de modification d'un vecteur (au nombre de 14) ont été mises en publique car chacune pourrait
avoir une utilité dans la suite du programme. Et en mettant toutes ces méthodes publique nous permettons au 
programmeur utilisateur de les utiliser avec simplicité sans avoir à comprendre les calculs qui donne le résultat demandé

P1.2: Concernant l'addition et la soustraction, on a décidé de "simuler" les dimensions manquantes en cas 
de différence entre les 2 vecteurs. Cela n'a aucun sens mathématiquement parlant mais d'une point de vue physique
ça peut en avoir un.

Concernant le produit scalaire et le produit vectorielle des erreures seront lancées si les dimensions ne sont pas les mêmes.

P4.1: Un constructeur de copie a été ajouté car il pourrait avoir une utilité potentielle dans le futur. Mieux vaut en mettre
un que de ne pas en mettre et en avoir besoin plus tard

P4.2: a) On aurait soit un array ou vector de dimension 3 ou 3 attributs représentant 2 angles et 1 norme qui représenteraient les coordonnées sphériques
      b) On ne pourrait plus faire la différence entre une déclaration en coordonnées sphériques et coordonnées cartésiennes au niveau du constructeur

P4.3: affiche: surcharge d'opérateur externe(ostream&) << qui appelle une méthode de type ostream& affiche
      compare: surcharge d'opérateur externe(bool) == et != qui appelle une méthode de type bool compare. 

P5.1: Nous avons décidé de mettre la masse ainsi que la masse volumique comme attribut, mais nous avons 
      crée une méthode qui permet, quand on vhange la Masse volumique, de calculer la nouvelle masse.

P5.2 Nous avons choisi que la fonction agis sur renvoye un void car elle a besoin "que" de changer
      les forces appliquées sur la Balle, la structure pris en argument.De plus agit_sur modifie déjà les
      forces appliquées sur la Balle puisque l'argument est pris en référence et non pas copie nous permettant 
      de modifier directement les donnée de la balle.
 
